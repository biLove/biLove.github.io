<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>常见机器学习算法 | Hexo</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="data," />
  

  <meta name="description" content="常见机器学习算法Classification 分类分类算法属于监督学习算法。监督学习算法表示你拥有大量的样本和正确答案。
分类算法的目的是为了找到决策边界，帮我们将数据进行分类，并用决策面来预测新的数据。输入训练集，包括大量的特征，和正确标签，训练得到分类模型，并进行评估和预测。
三种常用的分类算法为：朴素贝叶斯、SVMs、决策树，以下是三种算法的对比。



First Header
朴素贝叶斯">
<meta property="og:type" content="article">
<meta property="og:title" content="常见机器学习算法">
<meta property="og:url" content="http://lilyalove.com/2017/08/08/machine-learning/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="常见机器学习算法Classification 分类分类算法属于监督学习算法。监督学习算法表示你拥有大量的样本和正确答案。
分类算法的目的是为了找到决策边界，帮我们将数据进行分类，并用决策面来预测新的数据。输入训练集，包括大量的特征，和正确标签，训练得到分类模型，并进行评估和预测。
三种常用的分类算法为：朴素贝叶斯、SVMs、决策树，以下是三种算法的对比。



First Header
朴素贝叶斯">
<meta property="og:updated_time" content="2017-08-08T02:11:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="常见机器学习算法">
<meta name="twitter:description" content="常见机器学习算法Classification 分类分类算法属于监督学习算法。监督学习算法表示你拥有大量的样本和正确答案。
分类算法的目的是为了找到决策边界，帮我们将数据进行分类，并用决策面来预测新的数据。输入训练集，包括大量的特征，和正确标签，训练得到分类模型，并进行评估和预测。
三种常用的分类算法为：朴素贝叶斯、SVMs、决策树，以下是三种算法的对比。



First Header
朴素贝叶斯">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=eaf5ab1e" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css" type="text/css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/project/"
            target="_self"
            >
            项目
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#常见机器学习算法"><span class="toc-text">常见机器学习算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Classification-分类"><span class="toc-text">Classification 分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在选择监督算法时，需要考虑哪些东西？"><span class="toc-text">在选择监督算法时，需要考虑哪些东西？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Regression-回归"><span class="toc-text">Regression 回归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线性回归"><span class="toc-text">线性回归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Clustering-聚类"><span class="toc-text">Clustering 聚类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#K-means"><span class="toc-text">K-means</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dimensionality-reduction-降维"><span class="toc-text">Dimensionality reduction 降维</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主成分分析-PCA"><span class="toc-text">主成分分析 PCA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主成分："><span class="toc-text">主成分：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么用最大方差的方向作为主成分？"><span class="toc-text">为什么用最大方差的方向作为主成分？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二、第三主成分"><span class="toc-text">第二、第三主成分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Model-selection-模型选择"><span class="toc-text">Model selection 模型选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Preprocessing-预处理"><span class="toc-text">Preprocessing 预处理</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-machine-learning" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">常见机器学习算法</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.08.08</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Lilya Bao</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/数据分析/">数据分析</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://bilove.github.io//2017/08/08/machine-learning/#disqus_thread"></a>
        </span>
      

    </div>
  </header>

  <div class="article-content">
    
      <h1 id="常见机器学习算法"><a href="#常见机器学习算法" class="headerlink" title="常见机器学习算法"></a>常见机器学习算法</h1><h2 id="Classification-分类"><a href="#Classification-分类" class="headerlink" title="Classification 分类"></a>Classification 分类</h2><p>分类算法属于监督学习算法。监督学习算法表示你拥有大量的样本和正确答案。</p>
<p>分类算法的目的是为了找到决策边界，帮我们将数据进行分类，并用决策面来预测新的数据。<br>输入训练集，包括大量的特征，和正确标签，训练得到分类模型，并进行评估和预测。</p>
<p>三种常用的分类算法为：朴素贝叶斯、SVMs、决策树，以下是三种算法的对比。</p>
<table>
<thead>
<tr>
<th>First Header</th>
<th>朴素贝叶斯</th>
<th>SVMs</th>
<th>决策树</th>
</tr>
</thead>
<tbody>
<tr>
<td>优势</td>
<td>非常易于执行；特征空间非常大；运行非常容易；非常有效</td>
<td>支持向量机在具有复杂领域和明显分界的情况下，表现十分出色</td>
<td>测量决策树的生长情况，在适当的时间停止决策树生长非常重要。可以通过所谓的集成方法，从决策树中构建更大的分类器</td>
</tr>
<tr>
<td>缺点</td>
<td>有时会间断，无法识别组合的特征含义</td>
<td>在海量数据集中，它们的表现不太好。因为在这种训练集中，训练时间将是立方数。另外，噪音过多的情况下，效果也不好。所以，如果类严重重叠，你需要考虑独立证据，这时候朴素贝叶斯分类器会更有效</td>
<td>容易过拟合，尤其是在你具有包含大量特征的数据时，复杂的决策树可能会过度拟合数据。所以你需要谨慎对待使用决策树挑选的参数，调整参数以以防过度拟合</td>
</tr>
</tbody>
</table>
<p>如果你拥有海量的数据集，有很多很多的特征，直接可运行的SVMs的速度可能会很慢。数据的某些噪音，可能会导致过拟合现象。<br>所以，我们会在测试集上进行测试，看看它的表现如何。</p>
<h3 id="在选择监督算法时，需要考虑哪些东西？"><a href="#在选择监督算法时，需要考虑哪些东西？" class="headerlink" title="在选择监督算法时，需要考虑哪些东西？"></a>在选择监督算法时，需要考虑哪些东西？</h3><p>根据这个基本原则，可以对机器学习的算法进行选择。</p>
<ol>
<li>从执行效率上考虑</li>
<li>从特征空间上考虑</li>
<li>运行是否容易、有效</li>
<li>考虑算法的缺点</li>
</ol>
<p>后期继续总结。</p>
<h2 id="Regression-回归"><a href="#Regression-回归" class="headerlink" title="Regression 回归"></a>Regression 回归</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>$Y = β0 + β1 <em> X1 + β2 </em> X2 + …… + βn * Xn + \epsilon$</p>
<p>使用最小二乘法来求是的误差$\epsilon^2$和最小的β0，β1，……，βn。</p>
<p>评估线性回归好坏的指数是 $r^2$，$r^2$ 的范围是0~1，越接近1，说明回归线拟合的越好。</p>
<h2 id="Clustering-聚类"><a href="#Clustering-聚类" class="headerlink" title="Clustering 聚类"></a>Clustering 聚类</h2><p>聚类算法属于非监督算法。也就是我们拥有大量的数据，但是没有标记是否类别。<br>在这种情况下，所有的数据都属于一类。<br>我们需要根据数据的特征，把相似的数据分到一个簇里面，相异的数据分到不同的簇里面。</p>
<p>聚类常用于从多个维度对数据进行划分。例如，用于客户细分。</p>
<h3 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h3><p>原理是，通过对特征进行分析，找到潜在的分类，使得不同类之间距离较远，同一类之间距离都较近。从而完成数据划分。</p>
<p>核心算法是:</p>
<ol>
<li>设置N个中心点；</li>
<li>通过数据到这N个中心点的距离将数据进行划分；</li>
<li>调整中心点的位置，使得划分到同一个类里面的点，到中心点的位置最小；</li>
<li>再根据中心点的位置对所有的数据重新划分；</li>
<li>迭代第3步和第4步，直到不再发生变化。</li>
</ol>
<p>K-means的问题是，过度依赖最开始设置的中心点的位置。<br>很可能设置同样多的中心点，并迭代同样多的次数，最后划分出来的结果并不相同。</p>
<h2 id="Dimensionality-reduction-降维"><a href="#Dimensionality-reduction-降维" class="headerlink" title="Dimensionality reduction 降维"></a>Dimensionality reduction 降维</h2><p>当数据维度特别多时，会加重机器的运行负荷，同时会造成机器学习陷入细枝末节中。</p>
<p>在这种情况下，我们常常需要对数据进行降维，找到承载了大多数信息的主要特征，再将其用于真正的机器学习中。</p>
<p>常见的方法有主成分分析法</p>
<h3 id="主成分分析-PCA"><a href="#主成分分析-PCA" class="headerlink" title="主成分分析 PCA"></a>主成分分析 PCA</h3><p>PCA是一套用于各类数据分析的分析方法，这些分析包括特征集压缩。<br>每当你的数据需要直观化的时候，你都可以采用它。</p>
<p>如果你收到任何形状的数据，无论是何种形状，PCA会仅通过转化和轮换发现从旧坐标系统获得的新坐标系统。</p>
<p>方差：在统计学上，指数据分布的大致差幅。<br>对于一个具有较大方差的特征，它的样本散布的数值范围极大。对于一个方差较小的特征，它的样本则是紧密聚集在一起的。</p>
<h4 id="主成分："><a href="#主成分：" class="headerlink" title="主成分："></a>主成分：</h4><p>所以，根据上面的分析，我们可以知道，一个数据的主成分，就是具有最大方差的方向，如果针对很多维度的特征来说的话，就是具有最大方差的这个特征，就是主成分。</p>
<h4 id="为什么用最大方差的方向作为主成分？"><a href="#为什么用最大方差的方向作为主成分？" class="headerlink" title="为什么用最大方差的方向作为主成分？"></a>为什么用最大方差的方向作为主成分？</h4><p>因为它能最大程度的保留来自原始数据的信息量。使得我们在进行特征压缩时，可以保留更多的信息。</p>
<h4 id="第二、第三主成分"><a href="#第二、第三主成分" class="headerlink" title="第二、第三主成分"></a>第二、第三主成分</h4><p>同前面的定义，我们可以将每个特征的方差进行排序，就可以得到主成分的排序了。</p>
<p>在机器学习中，对于特征值很多的数据集，我们通常先用主成分分析法找到最重要的特征，再使用这些特征来进行机器学习，构建我们的预测模型。</p>
<p>好处是，可以让机器学习过程效率提高，同时避免被细枝末节所干扰，导致模型过拟合。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><p>PCA是将输入特征转化为其主成分的系统化方法，这些主成分之后可以供你使用，而非原始输入特征。<br>你将使用这些新特征用于分类和回归任务中。</p>
</li>
<li><p>主成分的定义是，数据中，使方差最大化的方向，它可以在你对这些特征进行投影或压缩时，将出现信息丢失的可能性降到最低。</p>
</li>
<li><p>你还可以对主成分划分等级，数据因特定主成分产生的方差越大，那么该主成分的级别越高。</p>
</li>
<li><p>主成分从某种程度上来说，是垂直的，（因为每个特征都在不同的维度上）所以从数学的角度来说，不同的主成分是不可能重叠的。</p>
</li>
<li><p>主成分数量是有上限的，最大值等于输入的特征量的数量。通常情况下，我们只使用最大的几个主成分。</p>
</li>
</ol>
<h2 id="Model-selection-模型选择"><a href="#Model-selection-模型选择" class="headerlink" title="Model selection 模型选择"></a>Model selection 模型选择</h2><p>暂无相关信息。</p>
<h2 id="Preprocessing-预处理"><a href="#Preprocessing-预处理" class="headerlink" title="Preprocessing 预处理"></a>Preprocessing 预处理</h2><p>暂无相关信息。</p>

    
  </div>
</article>

</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/project/"
              target="_self"
              >
              项目
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'http://lilyalove.com/2017/08/08/machine-learning/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
